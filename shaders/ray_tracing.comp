#version 450 core

layout(local_size_x = 32, local_size_y = 32) in;

#define FLOAT_MAX 10000000.0
#define FLOAT_MIN -10000000.0
#define PI 3.1415926535897
#define InvPI 0.318309886183
#define ShadowEpsilon 0.0001

struct Vertex {
	vec3 position;
	vec3 normal;
	vec3 tangent;
	vec3 bitangent;
	vec2 texcoord;
};

struct Material {
	vec3 emssive;
	vec3 baseColor;
	float subsurface, metallic, specular;
	float specularTint, roughness, anisotropic;
	float sheen, sheenTint, clearcoat;
	float clearcoatGloss, IOR, transmission;
};

struct Bound {
	vec3 pMin;
	vec3 pMax;
};

struct Triangle {
	ivec3 indices;
	int materialId;
	int textureId;
	float area;
};

struct BVHNode {
	Bound bound;
	int axis;
	int rightChild;
	int startIndex;
	int endIndex;
};


struct Ray {
	vec3 origin;
	vec3 dir;
	float tMax;
};

struct Light {
	int index; 
	float prefixArea; 
};

struct Interaction {
	vec3 position;
	vec3 normal;
	vec2 texcoord;
	int materialId;
	int textureId;
	float time;
};

struct Camera{
	vec3 eye;
	vec3 lowerLeftCorner;
	vec3 horizontal;
	vec3 vertical;
};

#define VERTEX_VEC3_COUNT 5
#define MATERIAL_VEC3_COUNT 6
#define TRIANGLE_VEC3_COUNT 2
#define BVHNODE_VEC3_COUNT 4
#define LIGHT_VEC3_COUNT 1

layout(binding = 0, rgba32f) uniform image2D output_image;
layout(binding = 30) uniform sampler2D HDRImage;

layout(binding = 0) uniform samplerBuffer vertices;
layout(binding = 1) uniform sampler1D materials;
layout(binding = 2) uniform samplerBuffer triangles;
layout(binding = 3) uniform samplerBuffer bvh_nodes;
layout(binding = 4) uniform samplerBuffer lights;
uniform int lightsSize; // lights元素个数
uniform float lightsSumArea; // lights表面积总和

uniform sampler2D textures[20]; // 物体纹理

ivec2 imagePos;
int bounce;

Vertex GetVertex(int i) {
	int offset = i * VERTEX_VEC3_COUNT;
	Vertex vertex;
	vertex.position  = texelFetch(vertices, offset + 0).rgb;
	vertex.normal    = texelFetch(vertices, offset + 1).rgb;
	vertex.tangent   = texelFetch(vertices, offset + 2).rgb;
	vertex.bitangent = texelFetch(vertices, offset + 3).rgb;
	vertex.texcoord  = texelFetch(vertices, offset + 4).rg;
	return vertex;
}
vec3 GetVertexPosition(int i) {
	int offset = i * VERTEX_VEC3_COUNT;
	return texelFetch(vertices, offset + 0).rgb;
}

vec3 GetVertexNormal(int i) {
	int offset = i * VERTEX_VEC3_COUNT;
	return texelFetch(vertices, offset + 1).rgb;
}

Material GetMaterial(int i) {
	int offset = i * MATERIAL_VEC3_COUNT;
	Material material;
	material.emssive   = texelFetch(materials, offset + 0, 0).rgb;
	material.baseColor = texelFetch(materials, offset + 1, 0).rgb;
	vec3 param1		   = texelFetch(materials, offset + 2, 0).rgb;
	material.subsurface = param1[0];
	material.metallic = param1[1];
	material.specular = param1[2];
	vec3 param2        = texelFetch(materials, offset + 3, 0).rgb;
	material.specularTint = param2[0];
	material.roughness = param2[1];
	material.anisotropic = param2[2];
	vec3 param3        = texelFetch(materials, offset + 4, 0).rgb;
	material.sheen = param3[0];
	material.sheenTint = param3[1];
	material.clearcoat = param3[2];
	vec3 param4        = texelFetch(materials, offset + 5, 0).rgb;
	material.clearcoatGloss = param3[0];
	material.IOR = param3[1];
	material.transmission = param3[2];
	return material;
}

Triangle GetTriangle(int i) {
	int offset = i * TRIANGLE_VEC3_COUNT;
	Triangle tri;
	tri.indices  = ivec3(texelFetch(triangles, offset + 0).rgb);
	vec3 param   = texelFetch(triangles, offset + 1).rgb;
	tri.materialId = int(param[0]);
	tri.textureId  = int(param[1]);
	tri.area  = param[2];
	return tri;
}

BVHNode GetBVHNode(int i) {
	int offset = i * BVHNODE_VEC3_COUNT;
	BVHNode node;
	node.bound.pMin = texelFetch(bvh_nodes, offset + 0).rgb;
	node.bound.pMax = texelFetch(bvh_nodes, offset + 1).rgb;
	vec3 param1     = texelFetch(bvh_nodes, offset + 2).rgb;
	node.axis = int(param1[0]);
	node.rightChild = int(param1[1]);
	node.startIndex = int(param1[2]);
	vec3 param2     = texelFetch(bvh_nodes, offset + 3).rgb;
	node.endIndex = int(param2[0]);
	return node;
}

Light GetLight(int i) {
	int offset = i * LIGHT_VEC3_COUNT;
	Light l;
	vec3 param = texelFetch(lights, offset + 0).rgb;
	l.index = int(param[0]);
	l.prefixArea = param[1];
	return l;
}

// 将三维向量direction转为HDR的纹理坐标uv，再从HDR纹理采样
const vec2 invAtan = vec2(0.1591, 0.3183);
vec3 SampleHDRMap(vec3 v) {
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
    uv *= invAtan;
    uv += 0.5;
	uv.y = 1.0 - uv.y;
    return texture(HDRImage, uv).rgb;
}

uniform mat4 ScreenToWorld;
uniform vec3 CameraEye;
uniform int SCREEN_WIDTH;
uniform int SCREEN_HEIGHT;
uniform Camera camera;

layout(binding = 1) buffer debug_output{
	float debug_data[];
};

Ray CameraGetRay(float s, float t) {
	Ray ray;
	ray.origin = camera.eye;
	ray.dir = camera.lowerLeftCorner + s * camera.horizontal + t * camera.vertical - camera.eye;
	ray.tMax = FLOAT_MAX;
	return ray;
}

bool BoundIntersect(in Bound bound, in Ray ray) {
	vec3 invdir = 1.0 / ray.dir;

    vec3 f = (bound.pMax - ray.origin) * invdir;
    vec3 n = (bound.pMin - ray.origin) * invdir;
	/* 
		各个分量最早离开包围盒的时刻为光线离开包围盒的时刻
		各个分量最晚进入包围盒的时刻为光线进入包围盒的时刻
	*/
    vec3 tmax = max(f, n);
    vec3 tmin = min(f, n);
    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    float t0 = max(tmin.x, max(tmin.y, tmin.z));

    return (t1 >= t0) ? true : false;
}

void swap(inout float f1, inout float f2) {
	float t = f1;
	f1 = f2;
	f2 = t;
}

// 输入随机数u[0, 1], 根据u和灯的表面积的一维分布选出灯光
int GetLightIndex(float u) {
	if (lightsSize == 0) return -1;
	int L = 0, R = lightsSize - 1, ans = -1;
	float randomArea = u * lightsSumArea;
	while (L <= R) { 
		int mid = L + R >> 1;
		if (GetLight(mid).prefixArea >= randomArea) {
			ans = mid;
			R = mid - 1;
		} else {
			L = mid + 1;
		}
	}
	return GetLight(ans).index;
}

// PBRT3中的三角形求交方法
bool TriangleIntersect(in Triangle tri, inout Ray ray, out Interaction isect) {
	const Vertex v0 = GetVertex(tri.indices[0]);
	const Vertex v1 = GetVertex(tri.indices[1]);
	const Vertex v2 = GetVertex(tri.indices[2]);

	vec3 p0 = v0.position;
	vec3 p1 = v1.position;
	vec3 p2 = v2.position;

	// 变换坐标系：光线原点在(0, 0, 0), 方向指向+z轴
	vec3 P0 = p0 - ray.origin;
	vec3 P1 = p1 - ray.origin;
	vec3 P2 = p2 - ray.origin;
	vec3 rd = ray.dir;
	// 光线z方向为0，选取另外两个最长的轴进行交换
	if (rd.z == 0) {
		if (abs(rd.x) > abs(rd.y)) {
			swap(P0.x, P0.z);
			swap(P1.x, P1.z);
			swap(P2.x, P2.z);
			swap(rd.x, rd.z);
		}
		else {
			swap(P0.y, P0.z);
			swap(P1.y, P1.z);
			swap(P2.y, P2.z);
			swap(rd.y, rd.z);
		}
	}
	// 错切变换，射线方向与+z轴对齐
	float invDz = 1.f / rd.z;
	P0.x = P0.x - P0.z * rd.x * invDz;
	P0.y = P0.y - P0.z * rd.y * invDz;
	P0.z *= invDz;
	P1.x = P1.x - P1.z * rd.x * invDz;
	P1.y = P1.y - P1.z * rd.y * invDz;
	P1.z *= invDz;
	P2.x = P2.x - P2.z * rd.x * invDz;
	P2.y = P2.y - P2.z * rd.y * invDz;
	P2.z *= invDz;

	// 边函数：由 p0 和 p1以及给定的第三点p指定的三角形面积的两倍
	float e0 = P1.x * P2.y - P1.y * P2.x;
	float e1 = P2.x * P0.y - P2.y * P0.x;
	float e2 = P0.x * P1.y - P0.y * P1.x;
	// 交点落在三角形外
	if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0)) {
		return false;
	}

	// 交点落在三角形外
	if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0)) return false;

	// 三角形三点共线
	float det = e0 + e1 + e2;
	if (det == 0) return false;

	/* 
		重心坐标：bi = ei / (e0 + e1 + e2) = bi / det
		插值后z = simga(bi * zi) = sigma(ei * zi) / det
		避免除法误差 判断z在光线范围内用sigma(ei * zi)与ray.tMax * det进行比较
	*/
	float tScaled = e0 * P0.z + e1 * P1.z + e2 * P2.z;
	if (det > 0 && (tScaled <= 0 || tScaled > ray.tMax * det)) return false;
	if (det < 0 && (tScaled >= 0 || tScaled < ray.tMax * det)) return false;

	// 重心坐标
	float invDet = 1.f / det;
	float t = tScaled * invDet;
	float b0 = e0 * invDet;
	float b1 = e1 * invDet;
	float b2 = e2 * invDet;
	
	vec2 uv0 = v0.texcoord;
	vec2 uv1 = v1.texcoord;
	vec2 uv2 = v2.texcoord;
	vec2 uvHit = uv0 * b0 + uv1 * b1 + uv2 * b2;

	vec3 normal0 = v0.normal;
	vec3 normal1 = v1.normal;
	vec3 normal2 = v2.normal;
	vec3 nHit;
	
	// 该三角形不存在法线
	if (normal0 == vec3(0) || normal1 == vec3(0) || normal2 == vec3(0)) {
		nHit = normalize(cross(p1 - p0, p2 - p0));
	} else {
		nHit = normal0 * b0 + normal1 * b1 + normal2 * b2;
	}

	// 光线击中三角形背面，需要反转法线
	if (dot(nHit, ray.dir) > 0) {
		nHit = -nHit;
	}
	nHit = normalize(nHit);
	isect.position = b0 * p0 + b1 * p1 + b2 * p2;
	isect.normal = nHit;
	isect.texcoord = uvHit;
	isect.textureId = tri.textureId;
	isect.materialId = tri.materialId;
	isect.time = t;
	ray.tMax = t; // 更新光线时间范围
	return true;
}

// 只进行相交测试
bool TriangleIntersectP(in Triangle tri, in Ray ray) {
	const Vertex v0 = GetVertex(tri.indices[0]);
	const Vertex v1 = GetVertex(tri.indices[1]);
	const Vertex v2 = GetVertex(tri.indices[2]);

	vec3 p0 = v0.position;
	vec3 p1 = v1.position;
	vec3 p2 = v2.position;

	// 变换坐标系：光线原点在(0, 0, 0), 方向指向+z轴
	vec3 P0 = p0 - ray.origin;
	vec3 P1 = p1 - ray.origin;
	vec3 P2 = p2 - ray.origin;
	vec3 rd = ray.dir;
	// 光线z方向为0，选取另外两个最长的轴进行交换
	if (rd.z == 0) {
		if (abs(rd.x) > abs(rd.y)) {
			swap(P0.x, P0.z);
			swap(P1.x, P1.z);
			swap(P2.x, P2.z);
			swap(rd.x, rd.z);
		}
		else {
			swap(P0.y, P0.z);
			swap(P1.y, P1.z);
			swap(P2.y, P2.z);
			swap(rd.y, rd.z);
		}
	}
	// 错切变换，射线方向与+z轴对齐
	float invDz = 1.f / rd.z;
	P0.x = P0.x - P0.z * rd.x * invDz;
	P0.y = P0.y - P0.z * rd.y * invDz;
	P0.z *= invDz;
	P1.x = P1.x - P1.z * rd.x * invDz;
	P1.y = P1.y - P1.z * rd.y * invDz;
	P1.z *= invDz;
	P2.x = P2.x - P2.z * rd.x * invDz;
	P2.y = P2.y - P2.z * rd.y * invDz;
	P2.z *= invDz;

	// 边函数：由 p0 和 p1以及给定的第三点p指定的三角形面积的两倍
	float e0 = P1.x * P2.y - P1.y * P2.x;
	float e1 = P2.x * P0.y - P2.y * P0.x;
	float e2 = P0.x * P1.y - P0.y * P1.x;
	// 交点落在三角形外
	if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0)) {
		return false;
	}

	// 交点落在三角形外
	if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0)) return false;

	// 三角形三点共线
	float det = e0 + e1 + e2;
	if (det == 0) return false;

	/* 
		重心坐标：bi = ei / (e0 + e1 + e2) = bi / det
		插值后z = simga(bi * zi) = sigma(ei * zi) / det
		避免除法误差 判断z在光线范围内用sigma(ei * zi)与ray.tMax * det进行比较
	*/
	float tScaled = e0 * P0.z + e1 * P1.z + e2 * P2.z;
	if (det > 0 && (tScaled <= 0 || tScaled > ray.tMax * det)) return false;
	if (det < 0 && (tScaled >= 0 || tScaled < ray.tMax * det)) return false;

	return true;
}

bool BVHIntersect(inout Ray r, out Interaction isect) {
	// 把将要访问的节点压入栈中
	int nodeStack[128], top = 0;
	nodeStack[top++] = 0;
	// 判断击中标志
	bool hit = false;
	while (top > 0) {
		const int curId = nodeStack[--top];
		const BVHNode node = GetBVHNode(curId);
		// 未击中该点包围盒则跳过
		if (!BoundIntersect(node.bound, r)) continue;
		if (node.rightChild == -1) { // 叶子节点
			for (int i = node.startIndex; i < node.endIndex; ++i) { // 每个三角形求交
				if (TriangleIntersect(GetTriangle(i), r, isect)) {
					hit = true;
				}
			}
		} else { // 非叶子节点
			// 在划分轴上光线方向为负方向，则需要先访问右儿子
			if (r.dir[node.axis] < 0) {
				nodeStack[top++] = curId + 1;
				// 判断是否击中另一个儿子的包围盒
				BVHNode rc = GetBVHNode(node.rightChild);
				if (BoundIntersect(rc.bound, r)) nodeStack[top++] = node.rightChild;
			} else {
				nodeStack[top++] = node.rightChild;
				BVHNode lc = GetBVHNode(curId + 1);
				if (BoundIntersect(lc.bound, r)) nodeStack[top++] = curId + 1;
			}
		}
	}
	return hit;
}

// 只进行相交测试
bool BVHIntersectP(inout Ray r) {
	// 把将要访问的节点压入栈中
	int nodeStack[128], top = 0;
	nodeStack[top++] = 0;
	while (top > 0) {
		const int curId = nodeStack[--top];
		const BVHNode node = GetBVHNode(curId);
		// 未击中该点包围盒则跳过
		if (!BoundIntersect(node.bound, r)) continue;
		if (node.rightChild == -1) { // 叶子节点
			for (int i = node.startIndex; i < node.endIndex; ++i) { // 每个三角形求交
				if (TriangleIntersectP(GetTriangle(i), r)) {
					return true;
				}
			}
		} else { // 非叶子节点
			// 在划分轴上光线方向为负方向，则需要先访问右儿子
			if (r.dir[node.axis] < 0) {
				nodeStack[top++] = curId + 1;
				// 判断是否击中另一个儿子的包围盒
				BVHNode rc = GetBVHNode(node.rightChild);
				if (BoundIntersect(rc.bound, r)) nodeStack[top++] = node.rightChild;
			} else {
				nodeStack[top++] = node.rightChild;
				BVHNode lc = GetBVHNode(curId + 1);
				if (BoundIntersect(lc.bound, r)) nodeStack[top++] = curId + 1;
			}
		}
	}
	return false;
}

uniform uint frameCount; // 用已经显示的总帧数和作为当前帧随机数种子
uint seed; // 实际参与运算的种子

uint wang_hash(inout uint seed) { // 迭代更新种子
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}
 
float Rand0To1() {
    return float(wang_hash(seed)) / 4294967296.0;
}

// 在切线空间下进行单位半球采样
vec3 UniformSampleHemisphere(in vec2 u) {
    float z = u[0];
    float r = sqrt(max(0.f, 1.f - z * z));
    float phi = 2 * PI * u[1];
    return vec3(r * cos(phi), r * sin(phi), z);
}

// 在三角形上采样，返回重心坐标
vec2 UniformSampleTriangle(in vec2 u) {
	float su0 = sqrt(u[0]);
	return vec2(1 - su0, u[1] * su0);
}

// 在三角形上采样，返回采样点信息
Interaction TriangleSample(in Triangle tri, in vec2 u) {
	vec2 b = UniformSampleTriangle(u);
	const vec3 p0 = GetVertexPosition(tri.indices[0]);
	const vec3 p1 = GetVertexPosition(tri.indices[1]);
	const vec3 p2 = GetVertexPosition(tri.indices[2]);
	const vec3 n0 = GetVertexNormal(tri.indices[0]);
	const vec3 n1 = GetVertexNormal(tri.indices[1]);
	const vec3 n2 = GetVertexNormal(tri.indices[2]);
	Interaction res;
	res.position = p0 * b[0] + p1 * b[1] + p2 * (1.f - b[0] - b[1]);
	if (n0 == vec3(0) || n1 == vec3(0) || n2 == vec3(0)) {
		res.normal = normalize(cross(p1 - p0, p2 - p0));
	} else {
		res.normal = n0 * b[0] + n1 * b[1] + n2 * (1.f - b[0] - b[1]);
	}
	res.normal = normalize(res.normal);
	res.texcoord = b;
	res.textureId = tri.textureId;
	res.materialId = tri.materialId;
	return res;
}

float sqr(float x) { return x*x; }

// 根据法线和出射方向建立切线空间
void BuildTangentSpace(in vec3 n, out vec3 t, out vec3 b) {
	// 切线
    if (n.z > 0.9999995f) t = vec3(1.0, 0.0, 0.0);
    else t = normalize(cross(n, vec3(0.0, 0.0, 1.0)));
    b = cross(n, t); // 次切线
}

// 向量v从切线空间转到世界空间
vec3 TangentToWorld(in vec3 t, in vec3 b, in vec3 n, in vec3 v) {
	return v.x * t + v.y * b + v.z * n;
}

// 余弦加权半球采样
vec3 SampleCosineHemisphere(in vec3 n, in vec3 t, in vec3 b) {
	float theta = Rand0To1(), r = Rand0To1();
	float x = r * sin(theta), y = r * cos(theta);
	float z = sqrt(1 - sqr(x) - sqr(y));
	return TangentToWorld(t, b, n, vec3(x, y, z));
}

float SchlickFresnel(float u) {
    float m = clamp(1-u, 0, 1);
    float m2 = m*m;
    return m2*m2*m; // pow(m,5)
}

float GTR1(float NdotH, float a) {
    if (a >= 1) return 1/PI;
    float a2 = a*a;
    float t = 1 + (a2-1)*NdotH*NdotH;
    return (a2-1) / (PI*log(a2)*t);
}

float GTR2(float NdotH, float a) {
    float a2 = a*a;
    float t = 1 + (a2-1)*NdotH*NdotH;
    return a2 / (PI * t*t);
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));
}

float smithG_GGX(float NdotV, float alphaG) {
    float a = alphaG*alphaG;
    float b = NdotV*NdotV;
    return 1 / (NdotV + sqrt(a + b - a*b));
}

float smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay) {
    return 1 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));
}

vec3 mon2lin(vec3 x) {
    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));
}

// DisneyBRDF镜面反射重要性采样
vec3 SampleGTR2(in vec3 n, in vec3 t, in vec3 b, in vec3 v, in float alpha) {
	float r1 = Rand0To1(), r2 = Rand0To1();
	float phiH = 2.0 * PI * r1;
	float cosThetaH = sqrt((1.0 - r2) / (1.0 + (alpha * alpha - 1.0) * r2));
	float sinThetaH = max(0.0, 1.0 - sqr(cosThetaH));
	float sinPhiH = sin(phiH), cosPhiH = 1.0 - sqr(sinPhiH);
	vec3 h = vec3(sinThetaH * cosPhiH, sinThetaH * sinPhiH, cosThetaH);
	h = TangentToWorld(t, b, n, h);
	return 2 * dot(v, h) * h - v;
}

// DisneyBRDF清漆重要性采样
vec3 SampleGTR1(in vec3 n, in vec3 t, in vec3 b, in vec3 v, in float alpha) {
	float r1 = Rand0To1(), r2 = Rand0To1();
	float phiH = 2.0 * PI * r1;
	float cosThetaH = sqrt((1.0 - pow(alpha * alpha, 1.0 - r2)) / (1.0 - alpha * alpha));
	float sinThetaH = max(0.0, 1.0 - sqr(cosThetaH));
	float sinPhiH = sin(phiH), cosPhiH = 1.0 - sqr(sinPhiH);
	vec3 h = vec3(sinThetaH * cosPhiH, sinThetaH * sinPhiH, cosThetaH);
	h = TangentToWorld(t, b, n, h);
	vec3 l = 2 * dot(v, h) * h - v;
	return l;
}

// DisneyBRDF重要性采样
vec3 SampleDisney(in vec3 V, in vec3 N, in vec3 T, in vec3 B, in Material material, out float pdf) {
	/*
		DisneyBRDF存在漫反射，镜面反射，清漆三种BRDF项，
		根据三种BRDF项的能量贡献随机选取一项进行采样
	*/
	float rDiffuse = (1.0 - material.metallic);
	float rSpecular = 1.0;
	float rClearcoat = 0.25 * material.clearcoat;
	float invSum = 1.0 / (rDiffuse + rSpecular + rClearcoat);

	float pDiffuse = rDiffuse * invSum;
	float pSpecular = rSpecular * invSum;
	float pClearcoat = rClearcoat * invSum;

	float r = Rand0To1();

	float alphaGTR1 = mix(0.1, 0.001, material.clearcoatGloss);
	float alphaGTR2 = max(0.001, sqr(material.roughness));

	vec3 L;
	if (r <= pDiffuse) {
		L = SampleCosineHemisphere(N, T, B);
	} else if (r <= pDiffuse + pSpecular) {
		L = SampleGTR2(N, T, B, V, alphaGTR2);
	} else {
		L = SampleGTR1(N, T, B, V, alphaGTR1);
	}

	/*
		分别计算L在三种BRDF采样下的概率密度，
		再根据能量贡献进行加权平均
	*/
	vec3 H = normalize(L + V);
	float LdotH = dot(L, H);
	float NdotH = dot(N, H);
	float NdotL = dot(N, L);

	float pdfDiffuse = NdotL * InvPI;
	float pdfSpecular =  GTR2(NdotH, alphaGTR2) * NdotH / (4.0 * LdotH);
	float pdfClearcoat = GTR1(NdotH, alphaGTR1) * NdotH / (4.0 * LdotH);

	pdf = pDiffuse * pdfDiffuse + pSpecular * pdfSpecular + pClearcoat * pdfClearcoat;
	return L;
}

vec3 DisneyPrincipledBRDF(vec3 V, vec3 N, vec3 L, vec3 X, vec3 Y, Material material) {
	float NdotL = dot(N, L);
    float NdotV = dot(N, V);
    if(NdotL < 0 || NdotV < 0) return vec3(0);

    vec3 H = normalize(L + V);
    float NdotH = dot(N, H);
    float LdotH = dot(L, H);

    // 各种颜色
    vec3 Cdlin = material.baseColor;
    float Cdlum = 0.3 * Cdlin.r + 0.6 * Cdlin.g  + 0.1 * Cdlin.b;
    vec3 Ctint = (Cdlum > 0) ? (Cdlin/Cdlum) : (vec3(1));   
    vec3 Cspec = material.specular * mix(vec3(1), Ctint, material.specularTint);
    vec3 Cspec0 = mix(0.08*Cspec, Cdlin, material.metallic); // 0° 镜面反射颜色
    vec3 Csheen = mix(vec3(1), Ctint, material.sheenTint);   // 织物颜色

    // 漫反射
    float Fd90 = 0.5 + 2.0 * LdotH * LdotH * material.roughness;
    float FL = SchlickFresnel(NdotL);
    float FV = SchlickFresnel(NdotV);
    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);

    // 次表面散射
    float Fss90 = LdotH * LdotH * material.roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);

     
    // 镜面反射 -- 各向同性
    /*float alpha = max(0.001, material.roughness * material.roughness);
    float Ds = GTR2(NdotH, alpha);
    float FH = SchlickFresnel(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs = smithG_GGX(NdotL, material.roughness);
    Gs *= smithG_GGX(NdotV, material.roughness);*/
    
    // 镜面反射 -- 各向异性
    float aspect = sqrt(1.0 - material.anisotropic * 0.9);
    float ax = max(0.001, sqr(material.roughness)/aspect);
    float ay = max(0.001, sqr(material.roughness)*aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = SchlickFresnel(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1), FH);
    float Gs;
    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);
    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);

    // 清漆
    float Dr = GTR1(NdotH, mix(0.1, 0.001, material.clearcoatGloss));
    float Fr = mix(0.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);

    // sheen
    vec3 Fsheen = FH * material.sheen * Csheen;
    
    vec3 diffuse = (1.0/PI) * mix(Fd, ss, material.subsurface) * Cdlin + Fsheen;
    vec3 specular = Gs * Fs * Ds;
    vec3 clearcoat = vec3(0.25 * Gr * Fr * Dr * material.clearcoat);

    return diffuse * (1.0 - material.metallic) + specular + clearcoat;
}

struct BounceLi {
	vec3 Li;
	vec3 f;
	float cosTheta;
	float pdf;
	float pR;
};

uniform int MAX_BOUNCE_DEPTH;

vec3 Li(in Ray reye) {
	Ray ray = reye;
	Interaction isect;

	vec3 Lo = vec3(0.0);
	vec3 c = vec3(1.0); // 第i次弹射光照的累计权重
	for (bounce = 0; bounce < MAX_BOUNCE_DEPTH; ++bounce) {
		if (!BVHIntersect(ray, isect)) {
			Lo += c * SampleHDRMap(normalize(ray.dir));
			return Lo;
		}
		const vec3 p = isect.position;
		const vec3 N = isect.normal;
		const vec3 V = normalize(-ray.dir);
		Material material = GetMaterial(isect.materialId);
		if (isect.textureId != -1) { // 将材质baseColor修改为纹理颜色
			material.baseColor = texture(textures[isect.textureId], isect.texcoord).rgb;
		}

		vec3 L, T, B;
		BuildTangentSpace(N, T, B);
		float pdf;

		// 自发光 只在第一次bounce接受物体的自发光
		vec3 LDirect = bounce == 0 ? material.emssive : vec3(0); 
		// 其他灯光的直接光照
		int triIndex = GetLightIndex(Rand0To1());
		if (triIndex != -1) { // 找到其中一个灯光
			// 在该三角形上采样
			const Triangle tri = GetTriangle(triIndex);
			Interaction triangleIsect = TriangleSample(tri, vec2(Rand0To1(), Rand0To1()));
			// 发射阴影射线，判断灯光与当前点之间有无遮挡
			Ray r;
			r.dir = triangleIsect.position - p;
			r.tMax = 1.0 - ShadowEpsilon; // 防止光线与目标物体相交
			r.origin = p + N * 0.0001; // 防止自相交
			if (!BVHIntersectP(r)) {
				// pdf为所有灯光表面积的倒数
				float l_Pdf = 1.f / lightsSumArea;
				float dis2 = r.dir.x * r.dir.x + r.dir.y * r.dir.y + r.dir.z * r.dir.z;
				vec3 li = GetMaterial(triangleIsect.materialId).emssive;
				// 针对灯光方向计算的brdf

				vec3 l_brdf = DisneyPrincipledBRDF(V, N, normalize(r.dir), T, B, material);
				LDirect += l_brdf * li * abs(dot(N, r.dir) * dot(triangleIsect.normal, r.dir)) / (l_Pdf * dis2);
			}
		}
		Lo += c * LDirect;
		// 随机采样wi得到的brdf
		L = SampleDisney(V, N, T, B, material, pdf);
		//L = SampleCosineHemisphere(N, T, B);
		//pdf = dot(N, L) * InvPI;
		c *= DisneyPrincipledBRDF(V, N, L, T, B, material) * abs(dot(N, L)) / pdf;
		ray.origin = p + N * 0.0001f;
		ray.dir = L;
		ray.tMax = FLOAT_MAX;
	}
	return Lo;
}


uniform int redraw;
void main() {
	imagePos = ivec2(gl_GlobalInvocationID.xy);
	seed = uint(uint(imagePos.x) * uint(1973) + 
				uint(imagePos.y) * uint(9277) + 
				uint(frameCount) * uint(26699)) | uint(1); // 初始化种子
	Ray ray = CameraGetRay(float(imagePos.x) / float(SCREEN_WIDTH), float(imagePos.y) / float(SCREEN_HEIGHT));
	vec3 color = Li(ray);
	color = clamp(color, vec3(0), vec3(1));
	// 多帧混合
	vec3 preColor = imageLoad(output_image, imagePos).rgb;
	imageStore(output_image, imagePos, vec4(mix(preColor, color, 1.0 / float(frameCount + 1)), 1.0));
}