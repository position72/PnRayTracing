#version 450 core

layout(local_size_x = 32, local_size_y = 32) in;

#define FLOAT_MAX 10000000.0
#define FLOAT_MIN -10000000.0
#define PI 3.1415926535897
#define INVPI 0.318309886183

struct Vertex {
	vec3 position;
	vec3 normal;
	vec3 tangent;
	vec3 bitangent;
	vec2 texcoord;
};

struct Material {
	vec3 emssive;
	vec3 baseColor;
	float subsurface, metallic, specular;
	float specularTint, roughness, anisotropic;
	float sheen, sheenTint, clearcoat;
	float clearcoatGloss, IOR, transmission;
};


struct Bound {
	vec3 pMin;
	vec3 pMax;
};

struct Triangle {
	ivec3 indices;
	ivec3 materialId;
};

struct BVHNode {
	Bound bound;
	int axis;
	int rightChild;
	int startIndex;
	int endIndex;
};


struct Ray {
	vec3 origin;
	vec3 dir;
	float tMax;
};

struct Interaction {
	vec3 position;
	vec3 normal;
	int materialId;
	float time;
};

struct Camera{
	vec3 eye;
	vec3 lowerLeftCorner;
	vec3 horizontal;
	vec3 vertical;
};

#define VERTEX_VEC3_COUNT 5
#define MATERIAL_VEC3_COUNT 6
#define TRIANGLE_VEC3_COUNT 2
#define BVHNODE_VEC3_COUNT 4

layout(binding = 0, rgba32f) writeonly uniform image2D output_image;

layout(binding = 0) uniform samplerBuffer vertices;
layout(binding = 1) uniform samplerBuffer materials;
layout(binding = 2) uniform samplerBuffer triangles;
layout(binding = 3) uniform samplerBuffer bvh_nodes;

Vertex GetVertex(int i) {
	int offset = i * VERTEX_VEC3_COUNT;
	Vertex vertex;
	vertex.position  = texelFetch(vertices, offset + 0).rgb;
	vertex.normal    = texelFetch(vertices, offset + 1).rgb;
	vertex.tangent   = texelFetch(vertices, offset + 2).rgb;
	vertex.bitangent = texelFetch(vertices, offset + 3).rgb;
	vertex.texcoord  = texelFetch(vertices, offset + 4).rg;
	return vertex;
}

Material GetMaterial(int i) {
	int offset = i * MATERIAL_VEC3_COUNT;
	Material material;
	material.emssive   = texelFetch(materials, offset + 0).rgb;
	material.baseColor = texelFetch(materials, offset + 1).rgb;
	vec3 param1		   = texelFetch(materials, offset + 2).rgb;
	material.subsurface = param1[0];
	material.metallic = param1[1];
	material.specular = param1[2];
	vec3 param2        = texelFetch(materials, offset + 3).rgb;
	material.specularTint = param2[0];
	material.roughness = param2[1];
	material.anisotropic = param2[2];
	vec3 param3        = texelFetch(materials, offset + 4).rgb;
	material.sheen = param3[0];
	material.sheenTint = param3[1];
	material.clearcoat = param3[2];
	vec3 param4        = texelFetch(materials, offset + 5).rgb;
	material.clearcoatGloss = param3[0];
	material.IOR = param3[1];
	material.transmission = param3[2];
	return material;
}

Triangle GetTriangle(int i) {
	int offset = i * TRIANGLE_VEC3_COUNT;
	Triangle tri;
	tri.indices     = ivec3(texelFetch(triangles, offset + 0).rgb);
	tri.materialId  = ivec3(texelFetch(triangles, offset + 1).rgb);
	return tri;
}

BVHNode GetBVHNode(int i) {
	int offset = i * BVHNODE_VEC3_COUNT;
	BVHNode node;
	node.bound.pMin = texelFetch(bvh_nodes, offset + 0).rgb;
	node.bound.pMax = texelFetch(bvh_nodes, offset + 1).rgb;
	vec3 param1     = texelFetch(bvh_nodes, offset + 2).rgb;
	node.axis = int(param1[0]);
	node.rightChild = int(param1[1]);
	node.startIndex = int(param1[2]);
	vec3 param2     = texelFetch(bvh_nodes, offset + 3).rgb;
	node.endIndex = int(param2[0]);
	return node;
}
uniform mat4 ScreenToWorld;
uniform vec3 CameraEye;
uniform int SCREEN_WIDTH;
uniform int SCREEN_HEIGHT;
uniform Camera camera;

layout(binding = 0) buffer debug_output{
	float debug_data[];
};

Ray CameraGetRay(float s, float t) {
	Ray ray;
	ray.origin = camera.eye;
	ray.dir = camera.lowerLeftCorner + s * camera.horizontal + t * camera.vertical - camera.eye;
	ray.tMax = FLOAT_MAX;
	return ray;
}

float BoundIntersect(in Bound bound, in Ray ray) {
	vec3 invdir = 1.0 / ray.dir;

    vec3 f = (bound.pMax - ray.origin) * invdir;
    vec3 n = (bound.pMin - ray.origin) * invdir;

    vec3 tmax = max(f, n);
    vec3 tmin = min(f, n);

    float t1 = min(tmax.x, min(tmax.y, tmax.z));
    float t0 = max(tmin.x, max(tmin.y, tmin.z));

    return (t1 >= t0) ? ((t0 > 0.0) ? (t0) : (t1)) : (-1);
}

void swap(inout float f1, inout float f2) {
	float t = f1;
	f1 = f2;
	f2 = t;
}


bool TriangleIntersect(const in Triangle tri, in Ray ray, out Interaction isect) {
	vec3 p0 = GetVertex(tri.indices[0]).position;
	vec3 p1 = GetVertex(tri.indices[1]).position;
	vec3 p2 = GetVertex(tri.indices[2]).position;

	// 根据三角形两边求法线
	vec3 normal = normalize(cross(p1 - p0, p2 - p0));

	// 光线在三角形背面
	if (dot(normal, ray.dir) > 0.0f) {
		normal = -normal;
	}

	float nDotd = dot(normal, ray.dir);
	// 光线与三角形平行
	if (abs(nDotd) < 0.00001f) { 
		return false;
	}
	float time = dot(normal, p0 - ray.origin) / nDotd;
	if (time >= ray.tMax || time < 0.0) {
		return false; // 击中时间大于光线的tMax，说明光线更早击中另外一个三角形
	}
	// 求光线击中三角形所在平面的点
	vec3 position = ray.origin + time * ray.dir;

	// 判断该点是否在三角形内部
	vec3 c1 = cross(p1 - p0, position - p0);
    vec3 c2 = cross(p2 - p1, position - p1);
    vec3 c3 = cross(p0 - p1, position - p2);
    bool r1 = (dot(c1, normal) > 0 && dot(c2, normal) > 0 && dot(c3, normal) > 0);
    bool r2 = (dot(c1, normal) < 0 && dot(c2, normal) < 0 && dot(c3, normal) < 0);
	if (r1 || r2) {
		ray.tMax = time; // 击中当前三角形，更新光线tMax
		isect.position = position;
		isect.normal = normal;
		isect.materialId = tri.materialId[0];
		isect.time = time;
		return true;
	}
	return false;
}

// PBRT3中的三角形求交方法
bool TriangleIntersect2(in Triangle tri, in Ray ray, out Interaction isect) {
	vec3 p0 = GetVertex(tri.indices[0]).position;
	vec3 p1 = GetVertex(tri.indices[1]).position;
	vec3 p2 = GetVertex(tri.indices[2]).position;

	// 变换坐标系：光线原点在(0, 0, 0), 方向指向+z轴
	vec3 P0 = p0 - ray.origin;
	vec3 P1 = p1 - ray.origin;
	vec3 P2 = p2 - ray.origin;
	vec3 rd = ray.dir;
	// 光线z方向为0，选取另外两个最长的轴进行交换
	if (rd.z == 0) {
		if (abs(rd.x) > abs(rd.y)) {
			swap(P0.x, P0.z);
			swap(P1.x, P1.z);
			swap(P2.x, P2.z);
			swap(rd.x, rd.z);
		}
		else {
			swap(P0.y, P0.z);
			swap(P1.y, P1.z);
			swap(P2.y, P2.z);
			swap(rd.y, rd.z);
		}
	}
	// 错切变换，射线方向与+z轴对齐
	float invDz = 1.f / rd.z;
	P0.x = P0.x - P0.z * rd.x * invDz;
	P0.y = P0.y - P0.z * rd.y * invDz;
	P0.z *= invDz;
	P1.x = P1.x - P1.z * rd.x * invDz;
	P1.y = P1.y - P1.z * rd.y * invDz;
	P1.z *= invDz;
	P2.x = P2.x - P2.z * rd.x * invDz;
	P2.y = P2.y - P2.z * rd.y * invDz;
	P2.z *= invDz;

	float e0 = P1.x * P2.y - P1.y * P2.x;
	float e1 = P2.x * P0.y - P2.y * P0.x;
	float e2 = P0.x * P1.y - P0.y * P1.x;
	// 交点落在三角形外
	if ((e0 < 0 || e1 < 0 || e2 < 0) && (e0 > 0 || e1 > 0 || e2 > 0)) {
		return false;
	}

	// 三角形三点共线
	float det = e0 + e1 + e2;
	if (det == 0) return false;

	float tScaled = e0 * P0.z + e1 * P1.z + e2 * P2.z;
	if (det > 0 && (tScaled <= 0 || tScaled > ray.tMax * det)) return false;
	if (det < 0 && (tScaled >= 0 || tScaled < ray.tMax * det)) return false;

	float invDet = 1.f / det;
	float t = tScaled * invDet;
	float b0 = e0 * invDet;
	float b1 = e1 * invDet;
	float b2 = e2 * invDet;
	
	vec3 pHit = b0 * p0 + b1 * p1 + b2 * p2;
	isect.position = pHit;
	isect.materialId = tri.materialId[0];
	isect.time = t;
	return true;
}

int debug_n;
bool BVHIntersect(in Ray r, out Interaction isect) {
	// 把将要访问的节点压入栈中
	int nodeStack[128], top = 0;
	nodeStack[top++] = 0;
	// 判断击中标志
	bool hit = false;
	float hit0, hit1;
	hit0 = BoundIntersect(GetBVHNode(0).bound, r);
	if (hit0 < 0) return hit;
	while (top > 0) {
		int curId = nodeStack[--top];
		BVHNode node = GetBVHNode(curId);
		if (node.rightChild == -1) { // 叶子节点
			for (int i = node.startIndex; i < node.endIndex; ++i) { // 每个三角形求交
				if (TriangleIntersect2(GetTriangle(i), r, isect)) {
					hit = true;
				}
			}
		} else { // 非叶子节点
			const BVHNode lc = GetBVHNode(curId + 1);
			const BVHNode rc = GetBVHNode(node.rightChild);
			//  与左右儿子包围盒相交
			hit0 = BoundIntersect(lc.bound, r);
			hit1 = BoundIntersect(rc.bound, r);
			// 就近选择下一个访问的节点
			if (hit0 > 0 && hit1 > 0) {
				if (hit0 < hit1) {
					nodeStack[top++] = node.rightChild;
					nodeStack[top++] = curId + 1;
				} else {
					nodeStack[top++] = curId + 1;
					nodeStack[top++] = node.rightChild;
				}
			} else if (hit0 > 0) {
				nodeStack[top++] = curId + 1;
			} else if (hit1 > 0) {
				nodeStack[top++] = node.rightChild;
			}
		}
	}
	return hit;
}

void main() {
	ivec2 p = ivec2(gl_GlobalInvocationID.xy);
	Ray ray = CameraGetRay(float(p.x) / float(SCREEN_WIDTH), float(p.y) / float(SCREEN_HEIGHT));
	Interaction isect;
	if (BVHIntersect(ray, isect)) {
		imageStore(output_image, p, vec4(0.8, 0.2, 0.3, 1.0));
	} 
}